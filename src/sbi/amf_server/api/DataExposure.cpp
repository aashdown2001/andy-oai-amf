/**
* Nudsf_DataRepository
* Nudsf Data Repository Service. Â© 2021, 3GPP Organizational Partners (ARIB, ATIS, CCSA, ETSI, TSDSI, TTA, TTC). All rights reserved. 
*
* The version of the OpenAPI document: 1.1.0-alpha.2
* 
*
* NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
* https://openapi-generator.tech
* Do not edit the class manually.
*/

#include "DataExposure.h"
//#include "Helpers.h"
#include "logger.hpp"
#include <nlohmann/json.hpp>
#include "TransData.hpp"
#include <stdlib.h>
#include <map>
#include <algorithm>
#include <cmath>
#include "amf_statistics.hpp"
using json = nlohmann::json;


extern statistics stacs;
//using namespace org::openapitools::server::model;

namespace oai {
namespace amf {
namespace api {

using namespace oai::amf::model;



DataExposureApi::DataExposureApi(std::shared_ptr<Pistache::Rest::Router> rtr) { 
    router = rtr;
}

void DataExposureApi::init() {
    setupRoutes();
}

void DataExposureApi::setupRoutes() {
    using namespace Pistache::Rest;

    Routes::Get(*router, base + "/getNFService", Routes::bind(&DataExposureApi::getNFService, this));
}

void DataExposureApi::getNFService(const Pistache::Rest::Request &request, Pistache::Http::ResponseWriter response) {
    
    printf("getNFService\n");
    try {
	json resp;
	int i = 0;
	for (auto const& ue : stacs.ue_infos) {
	  Logger::amf_app().info(
	   "|%7d|%22s|%18s|%15s|%16d|%11d|%9s|%7d|", i + 1,
	   ue.second.registerStatus.c_str(), ue.second.imsi.c_str(),
	   ue.second.guti.c_str(), ue.second.ranid, ue.second.amfid,
	   (ue.second.mcc + ue.second.mnc).c_str(), ue.second.cellId);
	   i++;
	   json ues;
	   ues["status"] = ue.second.registerStatus.c_str();
	   ues["imsi"] = ue.second.imsi.c_str();
	   ues["guti"] = ue.second.guti.c_str();
	   ues["ranid"] = ue.second.ranid;
	   ues["amfid"] = ue.second.amfid;
	   ues["location"]["plmn"] = (ue.second.mcc + ue.second.mnc).c_str();
	   ues["location"]["cellid"] = ue.second.cellId;
	   resp["ues"].push_back(ues);
	}
	for (i = 0; i < stacs.gnbs.size(); i++) {
	  Logger::amf_app().info(
            "|      %d      |    Connected     |         0x%x       |         %s   "
            "     |          %s, %d          | ",
            i + 1, stacs.gnbs[i].gnb_id, stacs.gnbs[i].gnb_name.c_str(),
           (stacs.gnbs[i].mcc + stacs.gnbs[i].mnc).c_str(), stacs.gnbs[i].tac);
	  json gnbs;
	  gnbs["gnb_id"] = stacs.gnbs[i].gnb_id;
	  gnbs["gnb_name"] = stacs.gnbs[i].gnb_name.c_str();
	  gnbs["tai"]["plmn"] = (stacs.gnbs[i].mcc + stacs.gnbs[i].mnc).c_str();
	  gnbs["tai"]["tac"] = stacs.gnbs[i].tac;
	  resp["gnbs"].push_back(gnbs);
	}
	printf("response: %s\n",resp.dump().c_str());
	response.send(Pistache::Http::Code::Ok, resp.dump().c_str());
	return;
    } catch (nlohmann::detail::exception &e) {
        //send a 400 error
        response.send(Pistache::Http::Code::Bad_Request, e.what());
        return;
    } catch (Pistache::Http::HttpError &e) {
        response.send(static_cast<Pistache::Http::Code>(e.code()), e.what());
        return;
    } catch (std::exception &e) {
        //send a 500 error
        response.send(Pistache::Http::Code::Internal_Server_Error, e.what());
        return;
    }
}
}
}
}


